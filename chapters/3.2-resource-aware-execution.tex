\subsection{Resource-aware execution}
\label{subsec:resource-aware-execution}

D. Duplyakin \etal~\cite{duplyakin2018} take a different approach to evaluate the resource usage of a given algorithm.
They demonstrate the use of \ac{AL}~\cite{active-learning} combined with \ac{GPR}~\cite{gaussian-process-regression} for optimizing sequences of parallel computer experiments.
The authors developed and experimentally evaluated a cost-efficient and memory-aware algorithm that guides experimentation in a 5-dimensional input space of machine-specific, numerical, and physical parameters.
D. Duplyakin \etal~\cite{duplyakin2018} key contribution is the development and experimental evaluation of a cost-efficient and memory-aware algorithm for \ac{AL}.
This algorithm learns from its mistakes, improving its ability to avoid simulations that violate memory constraints as the learning process evolves.
This way, it helps guide parameter choices when running a series of simulations in parameter sweeps, performance studies, or optimization and uncertainty quantification analysis settings.

Following a similar perspective, C. Tang \etal~\cite{tang2021} proposes a method to predict the resource usage of a given query.
Their approach was developed inside Twitter~\footnote{https://twitter.com/} and aimed to simplify calculating the resource usage of SQL queries.
During their research, the authors extracted keywords and features directly from the query itself and used those features to increase the prediction accuracy.
With that method, they achieved an average accuracy of 97\%.
Considering this, their research demonstrated that it is possible to use the source code of a given algorithm to predict its resource usage.
Although their context is limited to SQL queries, the same concept may work in other programming languages.

As demonstrated by D. Duplyakin \etal~\cite{duplyakin2018} and C. Tang \etal~\cite{tang2021}, it is possible to predict the resource usage of a single algorithm both by exploring critical aspects of the application, as well as by dynamically exploring unknown executions.
However, both approaches are limited to a specific use case and do not provide a general solution to predict the resource usage of any given algorithm.
